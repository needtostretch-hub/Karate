<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="manifest.json" />
  <title>Karate Flashcards</title>
  <style>
    :root { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin:0; background:#0b0b0b; color:#f2f2f2; }
    .wrap { max-width:760px; margin:0 auto; padding:16px; }
    h1 { font-size:18px; margin:8px 0 12px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select, textarea {
      background:#1b1b1b; color:#f2f2f2; border:1px solid #2a2a2a;
      padding:10px 12px; border-radius:12px; font-size:14px;
    }
    button { cursor:pointer; }
    .card {
      margin-top:14px; background:#131313; border:1px solid #262626; border-radius:18px;
      padding:18px; min-height:160px; display:flex; flex-direction:column; justify-content:center;
      user-select:none;
    }
    .front { font-size:30px; font-weight:800; line-height:1.1; }
    .back  { margin-top:12px; font-size:18px; line-height:1.3; color:#d9d9d9; display:none; }
    .card.revealed .back { display:block; }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid #2a2a2a; background:#141414; font-size:12px; color:#cfcfcf; }
    details { margin-top:14px; background:#121212; border:1px solid #262626; border-radius:14px; padding:10px; }
    textarea { width:100%; min-height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .muted { color:#bdbdbd; font-size:13px; }
    #importMsg { color:#ffcc66; margin-top:8px; min-height:18px; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Karate Japanese Flashcards</h1>

    <div class="row">
      <select id="categorySelect"></select>
      <button id="shuffleBtn">Shuffle</button>
      <button id="revealBtn">Reveal</button>
      <button id="prevBtn">◀︎ Prev</button>
      <button id="nextBtn">Next ▶︎</button>
    </div>

    <div class="card" id="card">
      <div class="row" style="justify-content:space-between; margin-bottom:8px;">
        <span class="pill" id="catPill">—</span>
        <span class="pill" id="idxPill">0/0</span>
      </div>
      <div class="front" id="frontText">—</div>
      <div class="back" id="backText">—</div>
      <div class="muted" style="margin-top:10px;">Tap the card to reveal/hide</div>
    </div>

    <details>
      <summary>Import / Edit cards</summary>
      <p class="muted">Paste CSV with headers: <span class="pill">front,back,category</span> (case-insensitive)</p>
      <textarea id="csvInput" placeholder="Paste CSV here..."></textarea>
      <div class="row">
        <button id="loadSampleBtn">Load sample deck</button>
        <button id="importBtn">Import CSV</button>
        <button id="exportBtn">Export current deck as CSV</button>
        <button id="clearBtn">Clear deck</button>
      </div>
      <div id="importMsg"></div>
    </details>

    <p class="muted" style="margin-top:12px;">
      If this page was added to Home Screen, updates may require removing and re-adding after we bump the cache.
    </p>
  </div>

<script>
(() => {
  const KEY_DECK = "kjp_deck_v3";
  const KEY_CAT  = "kjp_cat_v3";

  const SAMPLE = [
    { front: "Rei", back: "Bow", category: "Basic" },
    { front: "Hajime", back: "Begin", category: "Basic" },
    { front: "Yame", back: "Stop", category: "Basic" },
    { front: "Soto Uke", back: "Outer block", category: "Basic" },
    { front: "Mae Geri", back: "Front kick", category: "Kicks" }
  ];

  // Elements
  const categorySelect = document.getElementById("categorySelect");
  const shuffleBtn = document.getElementById("shuffleBtn");
  const revealBtn  = document.getElementById("revealBtn");
  const prevBtn    = document.getElementById("prevBtn");
  const nextBtn    = document.getElementById("nextBtn");

  const cardEl  = document.getElementById("card");
  const frontEl = document.getElementById("frontText");
  const backEl  = document.getElementById("backText");
  const catPill = document.getElementById("catPill");
  const idxPill = document.getElementById("idxPill");

  const csvInput = document.getElementById("csvInput");
  const loadSampleBtn = document.getElementById("loadSampleBtn");
  const importBtn = document.getElementById("importBtn");
  const exportBtn = document.getElementById("exportBtn");
  const clearBtn  = document.getElementById("clearBtn");
  const importMsg = document.getElementById("importMsg");

  // Basic safety check (this would explain your “nothing happens” issue)
  if (!importBtn || !loadSampleBtn || !csvInput) {
    alert("Page is missing expected elements. index.html is corrupted or not updated.");
    return;
  }

  let deck = loadDeck();
  let filtered = [];
  let idx = 0;

  function loadDeck() {
    try {
      const raw = localStorage.getItem(KEY_DECK);
      if (!raw) return SAMPLE.slice();
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) && parsed.length ? parsed : SAMPLE.slice();
    } catch {
      return SAMPLE.slice();
    }
  }
  function saveDeck() {
    localStorage.setItem(KEY_DECK, JSON.stringify(deck));
  }

  function currentCategory() {
    return localStorage.getItem(KEY_CAT) || "All";
  }
  function setCategory(cat) {
    localStorage.setItem(KEY_CAT, cat);
  }

  function categoriesFromDeck() {
    const set = new Set(deck.map(c => (c.category || "Uncategorised").trim()).filter(Boolean));
    return ["All", ...Array.from(set).sort((a,b)=>a.localeCompare(b))];
  }

  function applyFilter() {
    const cat = currentCategory();
    filtered = (cat === "All") ? deck.slice()
      : deck.filter(c => (c.category || "Uncategorised").trim() === cat);

    idx = filtered.length ? Math.min(idx, filtered.length - 1) : 0;
    render();
  }

  function render() {
    const total = filtered.length;
    if (!total) {
      frontEl.textContent = "No cards";
      backEl.textContent  = "Load sample or import CSV.";
      catPill.textContent = currentCategory();
      idxPill.textContent = "0/0";
      cardEl.classList.remove("revealed");
      return;
    }
    const c = filtered[idx];
    frontEl.textContent = c.front || "—";
    backEl.textContent  = c.back  || "—";
    catPill.textContent = c.category || "Uncategorised";
    idxPill.textContent = `${idx+1}/${total}`;
    cardEl.classList.remove("revealed");
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Delimited parser: supports comma / semicolon / tab. Quote-handling included.
  function parseDelimited(text) {
    const cleaned = text.replace(/\r/g, "").trim();
    if (!cleaned) return [];

    const lines = cleaned.split("\n").filter(l => l.trim().length);
    const header = lines[0];

    const counts = {
      ",": (header.match(/,/g) || []).length,
      ";": (header.match(/;/g) || []).length,
      "\t": (header.match(/\t/g) || []).length
    };
    const delimiter = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0] || ",";

    const rows = [];
    for (const line of lines) {
      let row = [];
      let cell = "";
      let inQuotes = false;

      for (let i=0; i<line.length; i++) {
        const ch = line[i];
        const nx = line[i+1];

        if (inQuotes) {
          if (ch === '"' && nx === '"') { cell += '"'; i++; }
          else if (ch === '"') inQuotes = false;
          else cell += ch;
        } else {
          if (ch === '"') inQuotes = true;
          else if (ch === delimiter) { row.push(cell.trim()); cell=""; }
          else cell += ch;
        }
      }
      row.push(cell.trim());
      rows.push(row);
    }
    return rows;
  }

  function toCSV(cards) {
    const esc = (s) => {
      const t = (s ?? "").toString();
      if (t.includes('"') || t.includes(',') || t.includes('\n')) return `"${t.replaceAll('"','""')}"`;
      return t;
    };
    const lines = [["front","back","category"], ...cards.map(c => [c.front, c.back, c.category])];
    return lines.map(r => r.map(esc).join(",")).join("\n");
  }

  function refreshCategoryUI() {
    const cats = categoriesFromDeck();
    categorySelect.innerHTML = "";
    for (const c of cats) {
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      categorySelect.appendChild(opt);
    }
    const cur = currentCategory();
    categorySelect.value = cats.includes(cur) ? cur : "All";
    applyFilter();
  }

  // Events
  cardEl.addEventListener("click", () => cardEl.classList.toggle("revealed"));
  revealBtn.addEventListener("click", () => cardEl.classList.toggle("revealed"));

  nextBtn.addEventListener("click", () => {
    if (!filtered.length) return;
    idx = (idx + 1) % filtered.length;
    render();
  });
  prevBtn.addEventListener("click", () => {
    if (!filtered.length) return;
    idx = (idx - 1 + filtered.length) % filtered.length;
    render();
  });

  shuffleBtn.addEventListener("click", () => {
    shuffle(deck);
    saveDeck();
    refreshCategoryUI();
    importMsg.textContent = "Shuffled deck.";
  });

  loadSampleBtn.addEventListener("click", () => {
    deck = SAMPLE.slice();
    saveDeck();
    refreshCategoryUI();
    importMsg.textContent = `Loaded sample deck (${deck.length} cards).`;
  });

  clearBtn.addEventListener("click", () => {
    deck = [];
    saveDeck();
    refreshCategoryUI();
    importMsg.textContent = "Cleared deck.";
  });

  exportBtn.addEventListener("click", () => {
    csvInput.value = toCSV(deck);
    importMsg.textContent = "Exported current deck into the textbox (copy/save it).";
  });

  importBtn.addEventListener("click", () => {
    const rows = parseDelimited(csvInput.value);
    if (rows.length < 2) { importMsg.textContent = "Nothing to import. Paste CSV first."; return; }

    const headers = rows[0].map(h => h.trim().toLowerCase());
    const iFront = headers.indexOf("front");
    const iBack  = headers.indexOf("back");
    const iCat   = headers.indexOf("category");

    if (iFront < 0 || iBack < 0 || iCat < 0) {
      importMsg.textContent = `Header must include front, back, category. Found: ${headers.join(", ")}`;
      return;
    }

    const cards = [];
    for (let r=1; r<rows.length; r++) {
      const row = rows[r];
      const front = (row[iFront] ?? "").trim();
      if (!front) continue;
      const back  = (row[iBack]  ?? "").trim();
      const category = ((row[iCat] ?? "").trim()) || "Uncategorised";
      cards.push({front, back, category});
    }

    if (!cards.length) { importMsg.textContent = "Imported 0 cards (front column empty?)."; return; }

    deck = cards;
    saveDeck();
    refreshCategoryUI();
    importMsg.textContent = `Imported ${cards.length} cards.`;
  });

  categorySelect.addEventListener("change", (e) => {
    setCategory(e.target.value);
    applyFilter();
  });

  // Init
  refreshCategoryUI();

  // Service worker (optional)
  if ("serviceWorker" in navigator) navigator.serviceWorker.register("./sw.js").catch(()=>{});
})();
</script>
</body>
</html>
